[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.13.3","content-config-digest","145088defa047255","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://chaeri-dev.netlify.app/\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[[null,{\"heading\":\"toc\",\"maxDepth\":3}]],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12],"browser-react-rendering",{"id":11,"data":13,"body":25,"filePath":26,"assetImports":27,"digest":42,"rendered":43,"legacyId":101},{"title":14,"imoji":15,"description":16,"pubDate":17,"author":18,"tags":19,"image":22},"브라우저 + 리액트 렌더링 과정에 대해 알아보자","⚙️","기술세미나로 리액트 렌더링 최적화라는 주제에 대해 준비했다. 렌더링 최적화 방법을 소개하기 전에 브라우저와 리액트가 각각 어떤 과정을 통해 렌더링이 되는지 알아볼 필요가 있었다. 이에 대해 확실하게 정리하고 넘어가고자 포스팅으로 남기려고 한다.",["Date","2022-08-08T00:00:00.000Z"],"서채연",[20,21],"Dev","Frontend",{"url":23,"alt":24},"__ASTRO_IMAGE_@/assets/posts/browser-react-rendering/browser-rendering.png","브라우저 렌더링 과정",">기술세미나로 리액트 렌더링 최적화라는 주제에 대해 준비했다. \u003Cbr/>\n>렌더링 최적화 방법을 소개하기 전에 브라우저와 리액트가 각각 어떤 과정을 통해 렌더링이 되는지 알아볼 필요가 있었다.\u003Cbr/>\n>이에 대해 확실하게 정리하고 넘어가고자 포스팅으로 남기려고 한다.\n\n\u003Cbr/>\n\n브라우저는 어떻게 HTML, CSS로 작성한 웹페이지를 화면에 렌더링 하는걸까?🤔\n\n## 브라우저 렌더링 과정\n브라우저는 Critical Rendering Path(CRP)라는 과정을 통해 렌더링이 진행된다.\n\n![browser-rendering](../../assets/posts/browser-react-rendering/browser-rendering.png)\n\nCritical Rendering Path(CRP)\n상세 과정은 다음과 같다.\n\n- 1단계 - HTML, CSS 변환(DOM, CSSOM 생성)\n\n- 2단계 - Render Tree 생성\n\n- 3단계 - Layout 과정\n\n- 4단계 - Painting 과정\n\n\n>1. HTML 파싱을 통한 DOM 생성\n>2. CSS 파싱을 통한 CSSOM 생성\n>3. DOM 트리와 CSSOM 트리를 결합해 렌더 트리 생성\n>4. layout 과정 실행\n>5. paint 및 composite 과정 실행\n\n\u003Cbr />\n\n### 1단계 - HTML, CSS 변환(DOM, CSSOM 생성)\n\n![critical-rendering-path](../../assets/posts/browser-react-rendering/critical-rendering-path.png)\n\n#### DOM(Document Object Model)이란?\n\n>HTML을 브라우저가 해석하기 편한 방식으로 변환한 객체 트리\n\n![DOM](../../assets/posts/browser-react-rendering/dom.png)\n\nCSSOM도 DOM과 똑같이 CSS 내용을 파싱하여 노드를 만들어 트리구조로 만든 것을 말한다.\n\n### 2단계 - Render Tree 생성\n\nDOM 트리와 CSSOM 트리를 결합해 Render Tree를 생성한다. 이는 웹페이지의 \"청사진\"이라고 생각하면 된다.\n\n![Render Tree](../../assets/posts/browser-react-rendering/render-tree.png)\n\n### 3단계 - Layout 과정\n\nRender Tree를 기반으로 실제 웹 페이지에 요소들의 배치를 결정하는 작업\n\n![Layout](../../assets/posts/browser-react-rendering/layout.png)\n\n\n### 4단계 - Painting 과정\n\n실제로 요소들을 화면에 그려내는 과정\n\n![Painting](../../assets/posts/browser-react-rendering/painting.png)\n\n\n\n\n그렇다면 업데이트 과정은 어떻게 되는 걸까?🤔\n\n\n\n### 업데이트 상황일 시,\nJavaScript가 DOM을 수정하면 업데이트가 발생한다.\u003Cbr/>\nDOM이 수정되면 CRP가 다시 실행이 된다.\n\n![Update DOM](../../assets/posts/browser-react-rendering/update-dom.png)\n\n\n#### ‼️여기서 Layout과 Painting 과정은 매우 비싼 과정임‼️\n\n![Update-layout-painting](../../assets/posts/browser-react-rendering/update-layout-painting.png)\n\n즉, 잦은 Reflow와 Repaint는 웹 성능 저하의 주범이 된다.\u003Cbr/>\n자바스크립트 수정이 여러 번 일어나게 된다면 Reflow와 Repaint 또한 여러 번 일어나기 때문이다.\n\n\n### 그래서 해결 방법이 뭔데?\n렌더링 성능의 저하를 줄이기 위해, 다음 그림과 같이 동시에 일어난 다양한 업데이트를 모아서 한 번에 수정 작업을 할 수 있도록 하는 것이다.\n\n![All Updates](../../assets/posts/browser-react-rendering/all-updates.png)\n\n\n이를 **React에서는 자동으로 해준다. 🪄**\n\n## 리액트 렌더링 과정\n\n리액트는 2단계를 거쳐 화면에 UI를 렌더링한다.\n\n\n1. Render Phase\n2. Commit Phase\n\n\n### Render Phase\nReact 컴포넌트가 렌더링해야 하는 UI를 **Virtual DOM**이라는 객체 값으로 변환하는 과정\n\n![Render Phase](../../assets/posts/browser-react-rendering/render-phase.png)\n\nRender Phase는 다음 단계로 나눌 수 있다.\n\n\n1. **컴포넌트를 호출해 결과값 계산**(React Component -> React Element)\n2. **React Element 들을 모아 Virtual DOM 생성**(React Element -> \bVirtual DOM)\n\n\n### 여기서 Virtual DOM(가상 돔)이란?\nReact Element라고 부르는 객체 값의 모임\u003Cbr/>\n실제 DOM은 아니다. 복사본이라고 생각하자.\u003Cbr/>\n실제 DOM과의 차이점은 브라우저에 있는 문서에 직접 접근할 수 없다는 점이다.(직접 수정 불가능!)\n\n\n이 가상 돔을 이용해서 리액트는 차이가 발생한 부분만을 브라우저 상의 실제 DOM에 적용해준다.\u003Cbr/>\n이 과정은 다음에 나오는 Commit Phase에 해당된다.\n\n### Commit Phase\nVirtual DOM을 Actual DOM에 반영한다.\u003Cbr/>\n그 후, 위에서 다룬 브라우저 렌더링 과정의 CRP 프로세스를 거치게 된다\n\n![Commit Phase](../../assets/posts/browser-react-rendering/commit-phase.png)\n\n\n## 리액트 렌더링 과정 정리\n\n![React Rendering](../../assets/posts/browser-react-rendering/react-rendering.png)\n\n#### 그렇다면 구체적으로 어떻게 DOM 업데이트를 최소화시키고 진행하는 걸까?\n2개의 가상돔(이전 가상돔과 바뀐 가상돔)의 차이점을 \u003CU>**diffing 알고리즘**\u003C/U>을 통해 알아내고\u003Cbr/>\n실제 돔에 한 번에 업데이트해서 렌더링을 최적화한다. 이를 \u003CU>**\"Reconciliation(재조정)\"**\u003C/U>이라고 한다.\n\n![Diffing](../../assets/posts/browser-react-rendering/dffing.png)\n\n\ndiffing 알고리즘과 ReactFiberReconciliation 관련해서는 더 깊게 파봐야할 것 같다.\n\n이는 따로 추후 포스팅을 해보겠다.","src/content/blog/browser-react-rendering.md",[28,29,30,31,32,33,34,35,36,37,38,39,40,41],"../../assets/posts/browser-react-rendering/browser-rendering.png","../../assets/posts/browser-react-rendering/critical-rendering-path.png","../../assets/posts/browser-react-rendering/dom.png","../../assets/posts/browser-react-rendering/render-tree.png","../../assets/posts/browser-react-rendering/layout.png","../../assets/posts/browser-react-rendering/painting.png","../../assets/posts/browser-react-rendering/update-dom.png","../../assets/posts/browser-react-rendering/update-layout-painting.png","../../assets/posts/browser-react-rendering/all-updates.png","../../assets/posts/browser-react-rendering/render-phase.png","../../assets/posts/browser-react-rendering/commit-phase.png","../../assets/posts/browser-react-rendering/react-rendering.png","../../assets/posts/browser-react-rendering/dffing.png","@/assets/posts/browser-react-rendering/browser-rendering.png","742abb432656086b",{"html":44,"metadata":45},"\u003Cblockquote>\n\u003Cp>기술세미나로 리액트 렌더링 최적화라는 주제에 대해 준비했다. \u003Cbr>\n렌더링 최적화 방법을 소개하기 전에 브라우저와 리액트가 각각 어떤 과정을 통해 렌더링이 되는지 알아볼 필요가 있었다.\u003Cbr>\n이에 대해 확실하게 정리하고 넘어가고자 포스팅으로 남기려고 한다.\u003C/p>\n\u003C/blockquote>\n\u003Cbr>\n\u003Cp>브라우저는 어떻게 HTML, CSS로 작성한 웹페이지를 화면에 렌더링 하는걸까?🤔\u003C/p>\n\u003Ch2 id=\"브라우저-렌더링-과정\">브라우저 렌더링 과정\u003C/h2>\n\u003Cp>브라우저는 Critical Rendering Path(CRP)라는 과정을 통해 렌더링이 진행된다.\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/browser-rendering.png&#x22;,&#x22;alt&#x22;:&#x22;browser-rendering&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Cp>Critical Rendering Path(CRP)\n상세 과정은 다음과 같다.\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>1단계 - HTML, CSS 변환(DOM, CSSOM 생성)\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>2단계 - Render Tree 생성\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>3단계 - Layout 과정\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>4단계 - Painting 과정\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Col>\n\u003Cli>HTML 파싱을 통한 DOM 생성\u003C/li>\n\u003Cli>CSS 파싱을 통한 CSSOM 생성\u003C/li>\n\u003Cli>DOM 트리와 CSSOM 트리를 결합해 렌더 트리 생성\u003C/li>\n\u003Cli>layout 과정 실행\u003C/li>\n\u003Cli>paint 및 composite 과정 실행\u003C/li>\n\u003C/ol>\n\u003C/blockquote>\n\u003Cbr>\n\u003Ch3 id=\"1단계---html-css-변환dom-cssom-생성\">1단계 - HTML, CSS 변환(DOM, CSSOM 생성)\u003C/h3>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/critical-rendering-path.png&#x22;,&#x22;alt&#x22;:&#x22;critical-rendering-path&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Ch4 id=\"domdocument-object-model이란\">DOM(Document Object Model)이란?\u003C/h4>\n\u003Cblockquote>\n\u003Cp>HTML을 브라우저가 해석하기 편한 방식으로 변환한 객체 트리\u003C/p>\n\u003C/blockquote>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/dom.png&#x22;,&#x22;alt&#x22;:&#x22;DOM&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Cp>CSSOM도 DOM과 똑같이 CSS 내용을 파싱하여 노드를 만들어 트리구조로 만든 것을 말한다.\u003C/p>\n\u003Ch3 id=\"2단계---render-tree-생성\">2단계 - Render Tree 생성\u003C/h3>\n\u003Cp>DOM 트리와 CSSOM 트리를 결합해 Render Tree를 생성한다. 이는 웹페이지의 “청사진”이라고 생각하면 된다.\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/render-tree.png&#x22;,&#x22;alt&#x22;:&#x22;Render Tree&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Ch3 id=\"3단계---layout-과정\">3단계 - Layout 과정\u003C/h3>\n\u003Cp>Render Tree를 기반으로 실제 웹 페이지에 요소들의 배치를 결정하는 작업\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/layout.png&#x22;,&#x22;alt&#x22;:&#x22;Layout&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Ch3 id=\"4단계---painting-과정\">4단계 - Painting 과정\u003C/h3>\n\u003Cp>실제로 요소들을 화면에 그려내는 과정\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/painting.png&#x22;,&#x22;alt&#x22;:&#x22;Painting&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Cp>그렇다면 업데이트 과정은 어떻게 되는 걸까?🤔\u003C/p>\n\u003Ch3 id=\"업데이트-상황일-시\">업데이트 상황일 시,\u003C/h3>\n\u003Cp>JavaScript가 DOM을 수정하면 업데이트가 발생한다.\u003Cbr>\nDOM이 수정되면 CRP가 다시 실행이 된다.\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/update-dom.png&#x22;,&#x22;alt&#x22;:&#x22;Update DOM&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Ch4 id=\"️여기서-layout과-painting-과정은-매우-비싼-과정임️\">‼️여기서 Layout과 Painting 과정은 매우 비싼 과정임‼️\u003C/h4>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/update-layout-painting.png&#x22;,&#x22;alt&#x22;:&#x22;Update-layout-painting&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Cp>즉, 잦은 Reflow와 Repaint는 웹 성능 저하의 주범이 된다.\u003Cbr>\n자바스크립트 수정이 여러 번 일어나게 된다면 Reflow와 Repaint 또한 여러 번 일어나기 때문이다.\u003C/p>\n\u003Ch3 id=\"그래서-해결-방법이-뭔데\">그래서 해결 방법이 뭔데?\u003C/h3>\n\u003Cp>렌더링 성능의 저하를 줄이기 위해, 다음 그림과 같이 동시에 일어난 다양한 업데이트를 모아서 한 번에 수정 작업을 할 수 있도록 하는 것이다.\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/all-updates.png&#x22;,&#x22;alt&#x22;:&#x22;All Updates&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Cp>이를 \u003Cstrong>React에서는 자동으로 해준다. 🪄\u003C/strong>\u003C/p>\n\u003Ch2 id=\"리액트-렌더링-과정\">리액트 렌더링 과정\u003C/h2>\n\u003Cp>리액트는 2단계를 거쳐 화면에 UI를 렌더링한다.\u003C/p>\n\u003Col>\n\u003Cli>Render Phase\u003C/li>\n\u003Cli>Commit Phase\u003C/li>\n\u003C/ol>\n\u003Ch3 id=\"render-phase\">Render Phase\u003C/h3>\n\u003Cp>React 컴포넌트가 렌더링해야 하는 UI를 \u003Cstrong>Virtual DOM\u003C/strong>이라는 객체 값으로 변환하는 과정\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/render-phase.png&#x22;,&#x22;alt&#x22;:&#x22;Render Phase&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Cp>Render Phase는 다음 단계로 나눌 수 있다.\u003C/p>\n\u003Col>\n\u003Cli>\u003Cstrong>컴포넌트를 호출해 결과값 계산\u003C/strong>(React Component -> React Element)\u003C/li>\n\u003Cli>\u003Cstrong>React Element 들을 모아 Virtual DOM 생성\u003C/strong>(React Element -> \bVirtual DOM)\u003C/li>\n\u003C/ol>\n\u003Ch3 id=\"여기서-virtual-dom가상-돔이란\">여기서 Virtual DOM(가상 돔)이란?\u003C/h3>\n\u003Cp>React Element라고 부르는 객체 값의 모임\u003Cbr>\n실제 DOM은 아니다. 복사본이라고 생각하자.\u003Cbr>\n실제 DOM과의 차이점은 브라우저에 있는 문서에 직접 접근할 수 없다는 점이다.(직접 수정 불가능!)\u003C/p>\n\u003Cp>이 가상 돔을 이용해서 리액트는 차이가 발생한 부분만을 브라우저 상의 실제 DOM에 적용해준다.\u003Cbr>\n이 과정은 다음에 나오는 Commit Phase에 해당된다.\u003C/p>\n\u003Ch3 id=\"commit-phase\">Commit Phase\u003C/h3>\n\u003Cp>Virtual DOM을 Actual DOM에 반영한다.\u003Cbr>\n그 후, 위에서 다룬 브라우저 렌더링 과정의 CRP 프로세스를 거치게 된다\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/commit-phase.png&#x22;,&#x22;alt&#x22;:&#x22;Commit Phase&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Ch2 id=\"리액트-렌더링-과정-정리\">리액트 렌더링 과정 정리\u003C/h2>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/react-rendering.png&#x22;,&#x22;alt&#x22;:&#x22;React Rendering&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Ch4 id=\"그렇다면-구체적으로-어떻게-dom-업데이트를-최소화시키고-진행하는-걸까\">그렇다면 구체적으로 어떻게 DOM 업데이트를 최소화시키고 진행하는 걸까?\u003C/h4>\n\u003Cp>2개의 가상돔(이전 가상돔과 바뀐 가상돔)의 차이점을 \u003Cu>\u003Cstrong>diffing 알고리즘\u003C/strong>\u003C/u>을 통해 알아내고\u003Cbr>\n실제 돔에 한 번에 업데이트해서 렌더링을 최적화한다. 이를 \u003Cu>\u003Cstrong>“Reconciliation(재조정)“\u003C/strong>\u003C/u>이라고 한다.\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/posts/browser-react-rendering/dffing.png&#x22;,&#x22;alt&#x22;:&#x22;Diffing&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Cp>diffing 알고리즘과 ReactFiberReconciliation 관련해서는 더 깊게 파봐야할 것 같다.\u003C/p>\n\u003Cp>이는 따로 추후 포스팅을 해보겠다.\u003C/p>",{"headings":46,"localImagePaths":94,"remoteImagePaths":95,"frontmatter":96,"imagePaths":100},[47,50,54,58,61,64,67,70,73,76,79,82,85,88,91],{"depth":48,"slug":49,"text":24},2,"브라우저-렌더링-과정",{"depth":51,"slug":52,"text":53},3,"1단계---html-css-변환dom-cssom-생성","1단계 - HTML, CSS 변환(DOM, CSSOM 생성)",{"depth":55,"slug":56,"text":57},4,"domdocument-object-model이란","DOM(Document Object Model)이란?",{"depth":51,"slug":59,"text":60},"2단계---render-tree-생성","2단계 - Render Tree 생성",{"depth":51,"slug":62,"text":63},"3단계---layout-과정","3단계 - Layout 과정",{"depth":51,"slug":65,"text":66},"4단계---painting-과정","4단계 - Painting 과정",{"depth":51,"slug":68,"text":69},"업데이트-상황일-시","업데이트 상황일 시,",{"depth":55,"slug":71,"text":72},"️여기서-layout과-painting-과정은-매우-비싼-과정임️","‼️여기서 Layout과 Painting 과정은 매우 비싼 과정임‼️",{"depth":51,"slug":74,"text":75},"그래서-해결-방법이-뭔데","그래서 해결 방법이 뭔데?",{"depth":48,"slug":77,"text":78},"리액트-렌더링-과정","리액트 렌더링 과정",{"depth":51,"slug":80,"text":81},"render-phase","Render Phase",{"depth":51,"slug":83,"text":84},"여기서-virtual-dom가상-돔이란","여기서 Virtual DOM(가상 돔)이란?",{"depth":51,"slug":86,"text":87},"commit-phase","Commit Phase",{"depth":48,"slug":89,"text":90},"리액트-렌더링-과정-정리","리액트 렌더링 과정 정리",{"depth":55,"slug":92,"text":93},"그렇다면-구체적으로-어떻게-dom-업데이트를-최소화시키고-진행하는-걸까","그렇다면 구체적으로 어떻게 DOM 업데이트를 최소화시키고 진행하는 걸까?",[28,29,30,31,32,33,34,35,36,37,38,39,40],[],{"title":14,"imoji":15,"author":18,"description":16,"image":97,"pubDate":98,"tags":99},{"url":41,"alt":24},["Date","2022-08-08T00:00:00.000Z"],[20,21],[28,29,30,31,32,33,34,35,36,37,38,39,40],"browser-react-rendering.md"]